% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/rayleigh_selection.R
\name{rayleigh_selection}
\alias{rayleigh_selection}
\title{Ranks features using Rayleigh quotients.}
\usage{
rayleigh_selection(g2, f, shift = 0, num_perms = 1000, seed = 10,
  num_cores = 1)
}
\arguments{
\item{g2}{an object of the class \code{simplicial} containing the nerve complex.}

\item{f}{a numeric vector or matrix specifying one or more functions with support on
the set of points whose significance will be assesed in the simplicial complex. Each
column corresponds to a point and each row specifies a different function.}

\item{shift}{real number specifying a shift that is added to \code{f}. Shifts are useful to
reduce the statistical power and rank very significant features without the need of using a
too large number of permutations. By default is set to 0.}

\item{num_perms}{number of permutations used to build the null distribution for each
feature. By default is set to 1000.}

\item{seed}{integer specifying the seed used to initialize the generator of permutations.
By default is set to 10.}

\item{num_cores}{integer specifying the number of cores to be used in the computation. By
default only one core is used.}
}
\value{
Returns a data frame with the value of the Rayleigh quotient score, its p-values, and
its value adjusted for multiple hypotheis testing using Benjamini-Hochberg procedure for each
feature.
}
\description{
Given a nerve complex and a set of features consisting on functions with support on
the set of points underlying the complex, it asseses the significance of each feature
in the simplicial complex by computing the Rayleigh quotient of the function with
respect to the combinatorial Laplace operator of the complex and comparing it with
the null distribution which results from reshufling the values of the function across
the point cloud.
}
\examples{
library(RayleighSelection)
# Load pre-processed LFW dataset (aligned, cropped, and normalized)
data("lfw")

# Compute reduced representation using Laplacian eigenmap of pixels with high variance
library(dimRed)
leim <- LaplacianEigenmaps()
lfw_top <- lfw[apply(lfw, 1, var) > 0.9,]
emb <- leim@fun(as(t(lfw_top), "dimRedData"), leim@stdpars)

# Compute Mapper representation using the Laplacian eigenmap as an auxiliary function and correlation
# distance as metric
library(TDAmapper)
lfw_distances <- (1.0 - cor(lfw_top))
m2 <- mapper2D(distance_matrix = lfw_distances,
               filter_values = list(emb@data@data[,1], emb@data@data[,2]),
               num_intervals = c(40,40),
               percent_overlap = 30,
               num_bins_when_clustering = 10);

# Compute the nerve complex
gg <- nerve_complex(m2$points_in_vertex)

# Compute R score, p-value, and q-value for the first 5 pixels
rayleigh_selection(gg, lfw[1:5,], shift=10.0)

}
